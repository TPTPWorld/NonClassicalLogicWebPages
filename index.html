<HTML>
<HEAD>
<TITLE>Non-classical Logics</TITLE>
<style type="text/css">
BODY {font-family:sans-serif;}
A:link {color: blue; text-decoration: none}
A:visited {color: red; text-decoration: none}
</style>
</HEAD>
<BODY ALIGN="JUSTIFY">
<HR><!------------------------------------------------------------------------>
<H1 ALIGN="LEFT">Non-classical Logics</H1>

by 
Tobias Glei&szlig;ner,
<A HREF="https://www.alexandersteen.de">Alexander Steen</A>,
<A HREF="http://www.cs.miami.edu/~geoff/">Geoff Sutcliffe</A>,
<A HREF="https://page.mi.fu-berlin.de/cbenzmueller/">Christoph Benzm&uuml;ller</A>
<P>
<HR><!------------------------------------------------------------------------>
<H2> Motivation </H2>

Extension of the TPTP TFX and THF dialects to support a wide range of 
non-classical logics with
<UL>
<LI> Minimal syntactic changes
<LI> User-friendly syntax (easy reading and writing of problems)
<LI> Developer-friendly syntax (easy parsing, minimal cases to consider e.g., 
     when defining semantics)
<LI> Uniform syntax for all non-classical logics
<LI> Consistency throughout TPTP dialects
</UL>

<H3>Overview</H3>
<UL>
<LI> A long form for all connectives of any non-classical logic.
     The long form contains the full name of a connective as defined words 
     e.g. <TT>$permissible</TT>.
<LI> A short form for selected connectives in selected non-classical logics,
     e.g., <TT>[.]</TT> and <TT>&lt;.&gt;</TT> for <TT>$necessary</TT> and
     <TT>$possible</TT> in alethic modal logic.
<LI> A seperate specification of the semantics.
</UL>

<EM><STRONG>
The descriptions and examples below are in terms of normal modal logic.
The syntax offers much more - see the section on the
<A HREF="#ExoticFuture">exotic future</A> below.
</STRONG></EM>

<P>
<HR><!------------------------------------------------------------------------>
<H2>Connectives Long Form</H2>

Connectives belonging to a logic get unique defined names, e.g., 
<TT>$necessary</TT>. 
The connective is written in <TT>{}</TT> brackets, and the application is 
functional.
Examples:
<PRE>
    tff(pigs_might_fly_type,type,pigs_might_fly: $o ).

    tff(no_flying_pigs,axiom,
        ~ {$possible}(pigs_might_fly) ).

    tff(something_is_possible,axiom,
        ? [P: $o] : {$possible}(P) ).

    thf(forbidden_flying_pigs,axiom,
        {$forbidden} @ pigs_might_fly ).

    thf(everything_is_permissible,axiom,
        ! [P: $o] : ( {$permissible} @ P ) ).
</PRE>

Connectives may have a list of parameters, where a parameter is one of:
<UL>
<LI> A optional single initial index term starting with <TT>#</TT>. 
     The index can be any constant (uninterpreted constant, number, TPTP
     defined constant) <!-- or bound variable,--> of any type. 
     The TPTP might provide predefined values, e.g., <TT>$past</TT>, for 
     individual logics. 
     Indices are distinct from each other and from object logic terms.
     Examples:
<PRE>
    tff(an_individual_type,type,me: $i ).

    tff(for_me_it_is_possible,axiom,
        {$possible:#me}(pigs_might_fly) ).

    tff(for_me_something_is_possible,axiom,
        ? [P: $o] : {$possible:#me}(P) ).

    thf(agent_type,type,agent: $tType ).

    thf(archer_type,type,archer: agent ).

    thf(archer_knows_flying_pigs,axiom,
        {$knows:#archer} @ pigs_might_fly ).

    thf(for_archer_everything_is_permissible,axiom,
        ! [P: $o] : ( {$permissible:#archer} @ P ) ).
</PRE>
<P>
<LI> A key-value expression of form <EM>LHS</EM><TT> := </TT><EM>RHS</EM> 
     where <EM>LHS</EM> is a TPTP defined constant, and <EM>RHS</EM> is a term
     (for TFF a <TT>tff_atomic_formula</TT>, for THF  a 
     <TT>thf_fof_function</TT>). 
     This is not used in normal modal logics, but in other logics, e.g.,
     epistemic logic ...
     <PRE>
    {$knows:#1}({$common: $group := [2,3,4]}(something_commonly_known_by_agents_2_3_and_4))
     </PRE>
</UL>

<!--
Users may define common abbreviations for connectives, e.g., <TT>box</TT>
for <TT>$necessary</TT> in modal logic, in statements with definition roles.
This is not used
Example:
<PRE>
    thf(knows, definition, archer_box = ^ [X: $o ({$knows:#archer}(X))).
</PRE>
... to say "archer knows X".
-->

<P>
<HR><!------------------------------------------------------------------------>
<H2>Connectives Short Form</H2>

The short forms provide shorthand for the long forms. 
Two short forms are available in normal modal logics:
<TT>[...]</TT>, <TT>&lt;...&gt;</TT>.
The short forms are associated by TPTP standards with specific long forms in 
specific logics, e.g., in alethic modal logic <TT>[...]</TT> is short for 
<TT>{$necessary:...}</TT> and <TT>&lt;...&gt;</TT> is short for 
<TT>{$possible:...}</TT>. 
There might not be a short form for every long form in a given logic. 
The short forms may be parameterized by an index, but nothing more.
A non-indexed short form has a period in the brackets.
Examples:
<PRE>
    tff(no_flying_pigs,axiom,
        ~ <.>(pigs_might_fly) ).

    tff(for_me_it_is_possible,axiom,
        <#me>(pigs_might_fly) ).

    thf(forbidden_flying_pigs,axiom,
        <.> @ pigs_might_fly ).

    thf(archer_knows_flying_pigs,axiom,
        [#archer] @ pigs_might_fly ).
</PRE>

Short forms and long forms can be used together, e.g., itâ€™s OK to use 
<TT>{$necessary}</TT> and <TT>[.]</TT> in the same problem or formula.
<P>
<HR><!------------------------------------------------------------------------>
<H2> Semantics Specification </H2>

Annotated formulae with the (new) role <TT>logic</TT> are used to specify 
the semantics of the logic.
Such a formula begins with the keyword for the logic, e.g.,
<TT>$modal</TT>, <TT>$alethic_modal</TT>, <TT>$deontic_modal</TT>,
<TT>$epistemic_modal</TT>, followed by <TT>==</TT> and a list of properties 
value assignments. 
Each specification is the property name, followed by <TT>==</TT> and either
a value or a tuple of specification details.
If the first element of a list of details is a value, that is the default
value for all cases that are not specified in the rest of the list. 
Each detail after the optional default value is the name of a relevant part 
of the vocabulary of the problem, followed by <TT>==</TT> and a value
for that named part.
<P>
The semantic specification typically comes first in a problem file.
A logic specification changes the meaning of things such as the boolean 
type <TT>$o</TT>, universal quantification with <TT>!</TT>, etc.
Their existing meaning in classical logic should not be confused with the
meaning in the declared logic.
<P>
For normal modal logics the properties that may be specified are 
<TT>$constants</TT>, <TT>$quantification</TT>, <TT>$consequence</TT>, and 
<TT>$modalities</TT>.
The <TT>$constants</TT>, <TT>$quantification</TT>, and <TT>$modalities</TT> 
may have individual values for constants and types, and the 
<TT>$consequence</TT> may have individual values for named axioms.
<UL> 
<LI> <TT>$constants</TT>
     <UL>
     <LI> <TT>$rigid</TT> - Rigid constants are independent of worlds.
     <LI> <TT>$flexible</TT> - Flexible constants are dependent on worlds.
     </UL>
<LI> <TT>$quantification</TT>
     <UL>
     <LI> <TT>$constant</TT> - Constant domain semantics has all world's
          domains fixed the same.
     <LI> <TT>$varying</TT> - Varying domain semantics has (potentially)
          different domains for each world.
     <LI> <TT>$cumulative</TT> - Cumulative domain semantics and varying,
          and the domain of each world is a superset of the domains of the
          worlds from which it can be reached.
     <LI> <TT>$decreasing</TT> - Decreasing domain semantics and varying,
          and the domain of each world is a subset of the domains of the
          worlds from which it can be reached.
     </UL>
<LI> <TT>$consequence</TT>
     <UL>
     <LI> <TT>$local</TT> - The formula is assumed to be true in the current 
          world.
     <LI> <TT>$global</TT> - The formula is assumed to be true in all worlds.
     </UL>
<LI> <TT>$modalities</TT> - These are specified in this
     <A HREF="https://en.wikipedia.org/wiki/Kripke_semantics#Common_modal_axiom_schemata">
     Wikipedia page</A>.
     <UL>
     <LI> A known system name may be given, as listed in
          <A HREF="Logics/LOG001_2.l"><TT>Logics/LOG001_2.l</TT></A>.
     <LI> A tuple of known axiom names may be given, as listed in
          <A HREF="Logics/LOG001_1.l"><TT>Logics/LOG001_1.l</TT></A>.
     </UL>
</UL>
<P>
See 
<A HREF="Problems/LogicSpecifications.p"><TT>LogicSpecifications.p</TT></A> 
for examples.
The BNF grammar is 
<A HREF="SyntaxBNF.html#logic_defn_rule">here</A>.
The grammar is not very restrictive on purpose, to enable working with other 
logics as well.
It is possible to create a lot of nonsense specifications, and to say the
same thing in different meaningful ways.
A tool to check the sanity of a specification is available.
<P>
<HR><!------------------------------------------------------------------------>
<H2> Examples </H2>

These examples can be run in Leo-III within 
<A HREF="http://www.tptp.org/cgi-bin/SystemOnTPTP">SystemOnTPTP</A>.
Leo-III embeds non-classical logic problems into plain THF, and solves the
THF problem. 
The embedding tool is available as Logic2THF in 
<A HREF="http://www.tptp.org/cgi-bin/SystemB4TPTP">SystemB4TPTP</A>, the
output from which can be given to any THF system.

<UL>
<LI> <A HREF="Problems/PUZ087~1.p">Wise men puzzle, TFF, epistemic modal
     logic, long connectives, indices and constants overlap</A>
<LI> <A HREF="Problems/PUZ087~2.p">Wise men puzzle, TFF, epistemic modal
     logic, long connectives, indices and constants distinct</A>
<LI> <A HREF="Problems/PUZ087~3.p">Wise men puzzle, TFF, generic modal
     logic, short connectives, indices and constants distinct</A>
<LI> <A HREF="Problems/PUZ087%231.p">Wise men puzzle, THF, epistemic modal
     logic, long connectives, indices and constants overlap</A>
<LI> <A HREF="Problems/PUZ087%232.p">Wise men puzzle, THF, epistemic modal
     logic, long connectives, indices and constants distinct</A>
<LI> <A HREF="Problems/PUZ087%233.p">Wise men puzzle, THF, generic modal
     logic, short connectives, indices and constants distinct</A>
<LI> <A HREF="Problems/PUZ999~1.p">Bungling chemists, TFF, alethic modal
     logic, short connectives</A>
<LI> <A HREF="Problems/PUZ999%231.p">Bungling chemists, THF, alethic modal
     logic, long connectives</A>
<LI> <A HREF="Problems/LCL870%231.p">Barcan formula, TFF, generic modal
     logic, short connectives</A>
<LI> <A HREF="Problems/LCL871%231.p">Converse Barcan formula, TFF, generic 
     modal logic, short connectives</A>
</UL>
<HR><!------------------------------------------------------------------------>
<H2> Logic Documentation </H2>

The various logics, the syntax used, the axiom schemes, and the semantics 
specification, are being semi-formally documented in a machine readable form.
This work is available in the
<A HREF="https://github.com/TPTPWorld/NonClassicalLogicWebPages/tree/master/Logics">Logics directory of the Github repository</A>.

<P>
<A NAME="ExoticFuture">
<HR><!------------------------------------------------------------------------>
<H2> Exotic Future </H2>

The use of the TPTP framework for non-classical logics, as presented so far, 
is conservative, adopting only widely accepted structures in normal modal 
logics.
The TPTP framework is capable of much more.
Some of our ideas are listed here, some relevant and unpolished files are
in the 
<A HREF="https://github.com/TPTPWorld/NonClassicalLogicWebPages/tree/master/ExoticFuture">ExoticFuture</A> directory, and feedback is welcome.
<UL>
<LI> Using object logic terms, including variables, as indices.
<LI> Non-normal modal logics are already supported in the syntax, and tool
     support will be added.
<LI> Encoding of description logic (ALC, ALCQI) problems in TPTP description
     logic format (an old TPTP effort) into modal logic.
<LI> Two more short forms <TT>{...}</TT>, and <TT>(...)</TT>. 
<LI> In logic specifications that <TT>$modalities</TT> may be written as
     THF formulae, or as frame conditions using <TT>$R</TT> as the 
     accessibility relation.
<LI> Problems with multiple logics together.
     (Short forms may not be used when multiple logics are used together - the 
     long forms have to be used, to avoid conflicting uses of the short forms.)
<LI> Problems with semantics templates that represent multiple semantics
     specifications, and a tool to burst these out into individual problem
     files.
<LI> More (non-modal) logics.
<LI> More and more
</UL>

<P>
<HR><!------------------------------------------------------------------------>
</BODY>
</HTML>
