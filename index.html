
HTML>
<HEAD>
<TITLE>Non-classical Logics</TITLE>
<style type="text/css">
BODY {font-family:sans-serif;}
A:link {color: blue; text-decoration: none}
A:visited {color: red; text-decoration: none}
</style>
</HEAD>
<BODY ALIGN="JUSTIFY">
<HR><!------------------------------------------------------------------------>
<H1 ALIGN="LEFT">Non-classical Logics</H1>

by 
Tobias Glei&szlig;ner,
<A HREF="https://www.alexandersteen.de">Alexander Steen</A>,
<A HREF="http://www.cs.miami.edu/~geoff/">Geoff Sutcliffe</A>,
<A HREF="https://page.mi.fu-berlin.de/cbenzmueller/">Christoph Benzm&uuml;ller</A>
<P>
<HR><!------------------------------------------------------------------------>
<H2> Motivation </H2>

Extension of the TPTP TFX and THF dialects to support a wide range of 
non-classical logics with
<UL>
<LI> Minimal syntactic changes
<LI> User-friendly syntax (easy reading and writing of problems)
<LI> Developer-friendly syntax (easy parsing, minimal cases to consider e.g., 
     when defining semantics)
<LI> Uniform syntax for all non-classical logics
<LI> Consistency throughout TPTP dialects
</UL>

<P>
<HR><!------------------------------------------------------------------------>
<H2> Syntactic Extension </H2>

<H3>Overview</H3>
<UL>
<LI> A long form for all operators (connectives) of any non-classical logic.
     The long form contains the full name of a non-classical operator as 
     defined words e.g. <TT>$permissible</TT>.
<LI> A short form for selected connectives in selected non-classical logics,
     e.g., <TT>[.]</TT> and <TT>&lt;.&gt;</TT> for <TT>$necessary</TT> and
     <TT>$possible</TT> in alethic modal logic.
</UL>

<H3>Long Form</H3>

Connectives belonging to a logic get unique defined names, e.g., 
<TT>$necessary</TT>. 
The connective is written in <TT>{}</TT> brackets, and the application is 
functional.
Examples:
<PRE>
    {$necessary}(something_that_is_necessary)
    {$knows} @ knowledge_context @ something_that_is_known
</PRE>

Connectives may be parameterized. A parameterized connective has the format
<PRE>
    {connective:parameter<SUB>1</SUB>,parameter<SUB>2</SUB>,...} 
</PRE>
where a parameter is one of:
<UL>
<LI> An index term starting with <TT>#</TT>. 
     The index can be any constant (uninterpreted constant, number, TPTP
     defined constant) <!-- or bound variable,--> of any type. 
     The TPTP might provide predefined values, e.g., <TT>$past</TT>, for 
     individual logics. 
     Indices are part of the object logic. 
     Examples:
<PRE>
    {$necessary:#1}(something_that_is_necessary_for_1)
    {$knows:#archer} @ knowledge_context @ something_that_is_known_by_archer
</PRE>
     Only one index is allowed.
     Indices cannot be complex terms/formulae.
     <P>
     Examples: <A HREF="WiseMenTFFLong.p">Wise men puzzle</A>,
               <A HREF="BunglingChemistTHFLong.p">Bungling Chemists</A>
<P>
<LI> A key-value expression of form <EM>LHS</EM><TT> := </TT><EM>RHS</EM> 
     where <EM>LHS</EM> is a TPTP defined constant, and <EM>RHS</EM> is a term
     (for TFF a <TT>tff_atomic_formula</TT>, for THF  a 
     <TT>thf_fof_function</TT>). 
     Examples:
     <PRE>
    {$knows:#1}({$common: $group := [#2,#3,#4]}(something_commonly_known_by_agents_2_3_and_4))
    {$necessary:$term := f(c)}(some_property)
     </PRE>
</UL>

Users may define common abbreviations for connectives, e.g., <TT>box</TT>
for <TT>$necessary</TT> in modal logic, in statements with definition roles.
Example:
<PRE>
    thf(knows, definition, archer_box = ^ [X: $o ({$knows:#archer}(X))).
</PRE>
... to say "archer knows X".

<H3>Short Form</H3>

The short forms provide shorthand for the long forms. 
four short forms are available <TT>[...]</TT>, <TT>&lt;...&gt;</TT>, 
<TT>{...}</TT>, and
<TT>(...)</TT>. 
The short forms are associated by TPTP standards with specific long forms in 
specific logics, e.g., in modal logic <TT>[...]</TT> is short for 
<TT>{$necessary:...}</TT> and <TT>&lt;...&gt;</TT> is short for 
<TT>{$possible:...}</TT>. 
A non-indexed short form have a period in the brackets.
The short forms may be parameterized by an index, but nothing more.
Examples:
<PRE>
    [.](arg1,arg2,...)
    <.> @ arg1 @ arg2 @ ...
    {.}(arg1,arg2,...)
    (.) @ arg1 @ arg2 @ ...
    [#1](arg1,arg2,...)
    <#agent> @ arg1 @ arg2 @ ...
    {#1}(arg1,arg2,...)
    (#agent) @ arg1 @ arg2 @ ...
</PRE>

Examples: <A HREF="WiseMenTHFShort.p">Wise men puzzle</A>,
          <A HREF="BunglingChemistTFFShort.p">Bungling Chemists</A>
<P>
There might not be a short form for every long form in a given logic. 
Short forms and long forms can be used together, e.g., itâ€™s OK to use 
<TT>{$necessarily}</TT> and <TT>[.]</TT> in the same problem or formula.
<P>
Short forms may not be used when multiple logics are used together - the 
long forms have to be used, to avoid conflicting uses of the short forms.

<P>
<A NAME="Alethic">
<HR><!------------------------------------------------------------------------>
<H2> Alethic Modal Logic (as an example) </H2>

The TPTP will define the following connectives:
<UL>
<LI> <TT>{$necessary}</TT>, with short form <TT>[.]</TT>
<LI> <TT>{$possible}</TT>, with short form <TT>&lt;.&gt;</TT>
</UL>

Some example uses in TFX:
<PRE>
    tff(pigs_might_fly_type,type,(
        pigs_might_fly: $o )).

    tff(no_flying_pigs,axiom,(
        ~ ( {$possible}(pigs_might_fly) ) )).

    tff(short_no_flying_pigs,axiom,(
        ~ ( <.>(pigs_might_fly) ) )).

    tff(an_individual_type,type,(
        me: $i )).

    tff(for_me_it_is_possible,axiom,(
        {$possible:#me}(pigs_might_fly) )).

    tff(short_for_me_it_is_possible,axiom,(
        <#me>(pigs_might_fly) )).

    tff(for_me_somthing_is_possible,axiom,(
        ? [P: $o] : {$possible:#me}(P) )).

    tff(short_for_me_somthing_is_possible,axiom,(
        ? [P: $o] : <#me>(P) )).

    tff(some_individual_says_flying_pigs,axiom,(
        ? [X: $i] : {$possible:#X}(pigs_might_fly) )).

    tff(short_some_individual_says_flying_pigs,axiom,(
        ? [X: $i] : <#X>(pigs_might_fly) )).

    tff(agent_type,type,(
        agent: $tType )).

    tff(archer_agent,type,(
        archer: agent )).

    tff(archer_says_no_flying_pigs,axiom,(
        ~ ( {$possible:#archer}(pigs_might_fly) ) )).

    tff(short_archer_says_no_flying_pigs,axiom,(
        ~ ( <#archer>(pigs_might_fly) ) )).

    tff(all_agents_say_flying_pigs,axiom,(
        ! [A: agent] : {$necessary:#A}(pigs_might_fly) )).

    tff(short_all_agents_say_flying_pigs,axiom,(
        ! [A: agent] : [#A](pigs_might_fly) )).

    tff(all_agents_say_everything,axiom,(
        ! [A: agent,P: $o] : {$necessary:#A}(P) )).

    tff(short_all_agents_say_everything,axiom,(
        ! [A: agent,P: $o] : [#A](P) )).

%----Are there modal examples with parameters?
</PRE>
<P>
The example uses in THF:
<PRE>
    thf(pigs_might_fly_type,type,(
        pigs_might_fly: $o )).

    thf(no_flying_pigs,axiom,(
        ~ ( {$possible} @ pigs_might_fly ) )).

    thf(short_no_flying_pigs,axiom,(
        ~ ( <.> @ pigs_might_fly ) )).

    thf(an_individual_type,type,(
        me: $i )).

    thf(for_me_it_is_possible,axiom,(
        {$possible:#me} @ pigs_might_fly )).

    thf(short_for_me_it_is_possible,axiom,(
        <#me> @ pigs_might_fly )).

    thf(for_me_somthing_is_possible,axiom,(
        ? [P: $o] : {$possible:#me} @ P )).

    thf(short_for_me_somthing_is_possible,axiom,(
        ? [P: $o] : <#me> @ P )).

    thf(some_individual_says_flying_pigs,axiom,(
        ? [X: $i] : {$possible:#X} @ pigs_might_fly )).

    thf(short_some_individual_says_flying_pigs,axiom,(
        ? [X: $i] : <#X> @ pigs_might_fly )).

    thf(agent_type,type,(
        agent: $tType )).

    thf(archer_says_no_flying_pigs,axiom,(
        ~ ( {$possible:#archer} @ pigs_might_fly ) )).

    thf(short_archer_says_no_flying_pigs,axiom,(
        ~ ( <#archer> @ pigs_might_fly ) )).

    thf(all_agents_say_flying_pigs,axiom,(
        ! [A: agent] : {$necessary:#A} @ pigs_might_fly )).

    thf(short_all_agents_say_flying_pigs,axiom,(
        ! [A: agent] : [#A] @ pigs_might_fly )).

    thf(all_agents_say_everything,axiom,(
        ! [A: agent,P: $o] : {$necessary:#A} @ P )).

    thf(short_all_agents_say_everything,axiom,(
        ! [A: agent,P: $o] : [#A] @ P )).
</PRE>
<P>
<HR><!------------------------------------------------------------------------>
<H2> Format for Semantics Specification </H2>

Annotated formulae with the (new) role <TT>logic</TT> are used to specify 
the semantics of the modal logic.
Such a formula begins with the keyword for the logic, which in this case is
<TT>$modal</TT>, followed by <TT>:=</TT> and a list of properties value
assignments. 
Properties may be specified for <TT>$constants</TT>, <TT>$quantification</TT>, 
<TT>$consequence</TT>, and <TT>$modalities</TT>.
Each specification is the property name, followed by <TT>:=</TT> and either
a value (see below for possible values) or a list of specification details.
If the first element of a list of details is a value, that is the default
value for all cases that are not specified in the rest of the list. 
Each detail after the optional default value is the name of a relevant part 
of the vocabulary used for the problem (e.g., the name of a type, a symbol, 
an axiom, etc.) and followed by <TT>:=</TT> and a specification for that
named part.
There may be more than one annotated formula providing the logic
specification, but no item's properties may be specified more than once.
As with the TPTP type system, all symbols must be defined before their
semantic properties are specified.
<P>
The semantic properties and their possible values are:
<UL> 
<LI> <TT>$constants</TT>
     <UL>
     <LI> <TT>$rigid</TT> - Rigid constants are independent of worlds.
     <LI> <TT>$flexible</TT> - Flexible constants are dependent on worlds.
     </UL>
<LI> <TT>$quantification</TT>
     <UL>
     <LI> <TT>$constant</TT> - Constant domain semantics has all world's
          domains fixed the same.
     <LI> <TT>$varying</TT> - Varying domain semantics has (potentially)
          different domains for each world.
     <LI> <TT>$cumulative</TT> - Cumulative domain semantics and varying,
          and the domain of each world is a superset of the domains of the
          worlds from which it can be reached.
     <LI> <TT>$decreasing</TT> - Decreasing domain semantics and varying,
          and the domain of each world is a subset of the domains of the
          worlds from which it can be reached.
     </UL>
<LI> <TT>$consequence</TT>
     <UL>
     <LI> <TT>$local</TT> - 
     <LI> <TT>$global</TT> - 
     </UL>
<LI> <TT>$modalities</TT> - These are specified in this
     <A HREF="https://en.wikipedia.org/wiki/Kripke_semantics#Common_modal_axiom_schemata">
     Wikipedia page</A>.
     <UL>
     <LI> <TT>$modal_system_K</TT> - 
     <LI> <TT>$modal_system_KB</TT> - 
     <LI> <TT>$modal_system_K4</TT> - 
     <LI> <TT>$modal_system_K5</TT> - 
     <LI> <TT>$modal_system_K45</TT> - 
     <LI> <TT>$modal_system_KB5</TT> - 
     <LI> <TT>$modal_system_D</TT> - 
     <LI> <TT>$modal_system_DB</TT> - 
     <LI> <TT>$modal_system_D4</TT> - 
     <LI> <TT>$modal_system_D5</TT> - 
     <LI> <TT>$modal_system_D45</TT> - 
     <LI> <TT>$modal_system_T</TT> - 
     <LI> <TT>$modal_system_B</TT> - 
     <LI> <TT>$modal_system_S4</TT> - 
     <LI> <TT>$modal_system_S5</TT> - 
<!--
     <LI> <TT>$modal_axiom_K</TT> - 
     <LI> <TT>$modal_axiom_T</TT> - 
     <LI> <TT>$modal_axiom_B</TT> - 
     <LI> <TT>$modal_axiom_D</TT> - 
     <LI> <TT>$modal_axiom_4</TT> - 
     <LI> <TT>$modal_axiom_5</TT> - 
-->
     </UL>
</UL>
<P>
The BNF grammar for this is linked from
<A HREF="http://www.tptp.org/TPTP/SyntaxBNF.html#logic_defn_rule">
here</A>, with the following being the semantic rules ...

<PRE>
&lt;logic_defn_rule>      :== &lt;logic_defn_LHS> &lt;assignment> &lt;logic_defn_RHS>
&lt;logic_defn_LHS>       :== &lt;logic_defn_value> | &lt;thf_top_level_type>  | &lt;name>
&lt;logic_defn_LHS>       :== $constants | $quantification | $consequence |
                           $modalities
%----The $constants, $quantification, and $consequence apply to all of the
%----$modalities. Each of these may be specified only once, but not necessarily
%----all in a single annotated formula.
&lt;logic_defn_RHS>       :== &lt;logic_defn_value> | &lt;thf_unitary_formula>
&lt;logic_defn_value>     :== &lt;defined_constant>
&lt;logic_defn_value>     :== $rigid | $flexible |
                           $constant | $varying | $cumulative | $decreasing |
                           $local | $global |
                           $modal_system_K | $modal_system_T | $modal_system_D |
                           $modal_system_S4 | $modal_system_S5 |
                           $modal_axiom_K | $modal_axiom_T | $modal_axiom_B |
                           $modal_axiom_D | $modal_axiom_4 | $modal_axiom_5
</PRE>
... with some additions that affect <TT>&lt;thf_unitary_formula></TT>
<PRE>
&lt;thf_pair_connective>  ::= &lt;infix_equality> | &lt;infix_inequality> |
                           &lt;binary_connective> | &lt;assignment>
&lt;assignment>           ::= :=
</PRE>

The grammar is not very restrictive on purpose, to enable working with other 
logics as well.
It is possible to create a lot of nonsense specifications, and to say the
same thing in different meaningful ways.
The TPTP will provide some standard logic definitions, and some examples of 
possible use are provided below.
We are considering implementing a tool to check the sanity of a specification.
The list of keywords is not final.
<P>
<H3> Examples </H3>

<PRE>
%----Standard S5
thf(simple_s5,logic,(
    $modal =
      [ $constants = $rigid,
        $quantification = $constant,
        $consequence = $global,
        $modalities = $modal_system_S5 ] )).

%----Constants The constant king_of_france has special semantics
thf(human_type,type,(
    human: $tType )).

thf(king_of_france_constant,type,(
    king_of_france: human )).

thf(constants,logic,(
    $modal =
      [ $constants =
          [ $constant,
            king_of_france = $flexible ],
        $quantification = $constant,
        $consequence = $global,
        $modalities = $modal_system_S5 ] )).

%----Quantification may be different for any base type or compound type e.g.
%----for type plushie
thf(plushie_type,type,(
    plushie: $tType )).

thf(quantification,logic,(
    $modal =
      [ $constants = $rigid,
        $quantification =
          [ $constant,
            plushie = $varying ],
        $consequence = $global,
        $modalities = $modal_system_S5 ] )).

thf(different_modality,logic,(
    $modal = 
      [ $constants = $rigid,
        $quantification =
          [ $constant,
            plushie = $varying ],
        $consequence = $global,
        $modalities = 
          [ $modal_system_S4,
            #king_of_france = $modal_system_S5 ] ] )).

%----Consequence. All axioms same consequence except for ax1 which has a
%----special consequence
thf(ax1,axiom,(
    $true )).

thf(different_consequence,logic,(
    $modal =
      [ $constants = $rigid,
        $quantification = $constant,
        $consequence =
          [ $global,
            ax1 = $local ],
        $modalities = $modal_system_S5 ] )).
</PRE>

<H3> Exotic Examples </H3>

It's not clear if/how these might be supported - just putting out ideas here.

<PRE>
%----Something more exotic. a, b, and c are indices for multi-modal 
%----operators, e.g., If a is a $int, it could be used with $box_int
%----in an expression such as $box_int @ a @ p.
thf(exotic,logic,(
    $modal =
      [ $constants = $flexible,
        $quantification = $cumulative,
        $consequence =
          [ $global,
            ax1 = $local ],
        $modalities =
          [ ! [X: $int] :
              ( X =
                  [ $modal_axiom_K,
                    $modal_axiom_D ] ),
            a = $modal_system_S5,
            b = $modal_system_KB,
            c = $modal_system_K ] ] )).

thf(quantification,logic,( 
    $modal =
      [ $constants = $rigid,
        $quantification = $constant,
        $consequence = $global,
        $modalities =
          ! [X: $int] :
            $ite($greater @ X @ 0,$modal_system_K,$modal_system_KB)] )).

thf(instantiated_modality,logic,(
    $modal =
      [ $constants = $rigid,
        $quantification = $constant,
        $consequence = $global,
        $modalities =
          [ $modal_axiom_K,
             {$necessarily:#archer} = $modal_system_D ] ] )).

thf(funky_mixed,logic,(
    [ $modal =
        [ $constants = $rigid,
          $quantification = $constant,
          $consequence = $global,
          $modalities = $modal_system_S5 ],
      $dialetheic =
        [ $truth_values =
            [ $true,
              $false,
              $both ],
          $embedding = $translational ] ] )).

%----Default modality S5 as list of axioms K + T + 5. This is currently not 
%----supported.
thf(simple_s5_v3,logic,(
    $modal =
      [ $constants = $rigid,
        $quantification = $constant,
        $consequence = $global,
        $modalities =
          [ $modal_axiom_K,
            $modal_axiom_T,
            $modal_axiom_5 ] ] )).

</PRE>
<P>
<HR><!------------------------------------------------------------------------>
<P>
<HR><!------------------------------------------------------------------------>
</BODY>
</HTML>
